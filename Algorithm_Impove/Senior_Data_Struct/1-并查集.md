[TOC]

## 1：并查集

```c++
一： 并查集实现的操作：
    
    1： 将两个集合进行合并；

    2： 查询某个节点的祖宗节点；

        扩展操作：

    3： 维护 1 ，2 操作的同时， 记录每个集合的大小： (一般会将集合的大小绑定在根节点之上)
            集合的大小是固定的，是本身的属性，与集合中的元素无关。

    4： 每个点到根节点的距离。 (绑定于每个元素之上)
            可以将这个距离定义为 此子节点与根节点之间的关系。
    
    
二：并查集的优化：
    1：路径压缩；  o(logn)
    2：按秩合并：  o(logn)
    3：上述两者合并使用 ， o(a(n)) --> 基本等同于线性的时间复杂度。
    
三：边权并查集 和 扩展域并查集。
    
    时间复杂度：边权并查集是与维护的 节点数k 无关。
    		  扩展域并查集是与 维护的节点数 k 有关。 o(k);
	思想：
        边权并查集： 维护 "相对关系"，即 "相对距离"  (处理多分类问题)
        
        扩展域并查集： "枚举"的思想。对于不同的分类全部枚举。
        
```

#### 1250：格子游戏

https://www.acwing.com/problem/content/1252/

```c++
需要判断的是输赢的问题：当图形封闭的时候就应该结束游戏。
    关键点：当一条边的两个端点都在同一个集合（连通块）中时，就会形成封闭图形。

这里数据的时候使用 一维数组 来迎合我们的并查集数组， (x,y) -->  x*n + y (前提是下标从0 开始)
```

```c++
#include<iostream>
using namespace std;

const int N = 40010;
int n, m;
int p[N];

int find(int x)
{
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int get(int x,int y)
{
    return x * n  + y;
}

int main()
{
    cin >> n >> m;
    //  初始化并查集数组
    for(int i = 0 ; i < n * n ; i++) p[i] = i;
    
    int res = 0;
    for(int i = 1 ; i <= m ; i++ )
    {
        int x , y;
        char d;
        cin >> x >> y >> d;
        
        // 将 二维坐标转换为 一维坐标
        x-- ,y--;
        int a = get(x,y); //  a 是 (x,y) 的一维坐标
        
        //  终点编号
        int b;
        if(d == 'D') b = get(x + 1 ,y);
        else b = get(x, y + 1);
        
        //  判断是否成环（既 连个节点祖宗节点都是同一个）
        int pa = find(a),pb = find(b);
        if(pa == pb)
        {
            res = i;
            break;
        }
        p[pa] = pb;
   
    }
    
    if(!res) puts("draw");
    else cout << res << endl;
    return 0;
}
```

#### 1251：搭配购买

https://www.acwing.com/problem/content/1254/

```c++
关键点: 当买一件物品的时候，就必须搭配购买。
    所以就相当于 购买某个集合中的某个物品时，整个集合中的物品都要买。

	1：将所有搭配购买的节点组成一个集合。找出这个
    2：将每个集合作为 一个物品，做 01 背包。
    
  在分出集合时，可以算出一些附加属性： 总体积，总价值。（绑定在集h）
    
```

```c++

```



























