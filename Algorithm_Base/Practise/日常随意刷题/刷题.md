[TOC]

#### 尼文数

https://zoj.pintia.cn/problem-sets/91827364500/problems/91827364653

##### 任意进制数字转换为十进制

$\sum_{i=0}^{k}x_i * b^i$    $k$ 为数的位数，$b$ 为任意进制。其结果就是十进制数。

根据秦九韶算法：
$$
f(x) = a_nx^n + a_{n-1}x^{n-1} + ... + a_1x + a_0
$$

$$
=(...((a_nx + a_{n-1})x)+a_{n-2})x+...+a_1)x+a_0
$$

那么就可以使用迭代的方式来求。

要注意是**从最高项向外迭代**，所以要从数字的最高位开始迭代计算。

```c++
// 输入进制和字符串  转 十进制数字：
string s;
int b;

cin >> b >> s;

int num = 0;

for(int i = 0 ; i < s.size() ; i++) // 这里的s[0] 为数字最高项
{
	num = (s[i] - '0') + num * b;
}
```



```c++
#include <stdio.h>
#include <cstring>
#include <iostream>
using namespace std;

string s;

int main()
{
    int t, b;
    scanf("%d", &t);
    while(t--) {
        while(~scanf("%d", &b) && b) {
            int sum = 0, num = 0, i;
            cin >> s;
            for(i = 0; i < s.size(); i++) {
                sum += s[i] - '0';
                num = num * b + s[i] - '0';
            }
            printf("%s\n", num % sum == 0 ? "yes" : "no");
        }
        if(t) printf("\n");
    }
    return 0;
}
```





#### 第 k 个除数

https://www.acwing.com/problem/content/description/3786/

```
n 的数据范围在  10^15 次方， 不能直接暴力的 遍历 n。
并且会爆 int ，使用 long long 来存储。

注意题目描述：
	可与 整数 n 的第 k 小正整数。
	整数 n ，n 是做为被除数。
	
	可以整除 n 的数集是指 n 的所有约数。
	n / i == 整数， 指的是  n  可以整除以  i

通过试除法找到 所有的约数。
数据范围 最大在  sqrt(10^15) 。这样就不会 TLE了。   o(sqrt(n))
因为找 第 k 个数，将其 排序后找出即可。 o(nlogn)

```

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main() {
    ll n, k;
    cin >> n >> k;

    vector<ll> v;

    for(ll i = 1; i <= n / i; i++) { 
        if(n % i == 0) {
            v.push_back(i);
            if(i != n / i) v.push_back(n / i);
        }
    }

    sort(v.begin(), v.end());

    if(k > v.size()) cout << -1 << endl;
    else cout << v[k - 1];

}
```

#### A+B

https://www.acwing.com/problem/content/description/3609/

```
char             -128 ~ +127        (1 Byte)
short             -32767 ~ + 32768    (2 Bytes)
unsigned short     0 ~ 65536        (2 Bytes)
int             -2147483648 ~ +2147483647   (4 Bytes)
unsigned int         0 ~ 4294967295    (4 Bytes)
long == int
long long         -9223372036854775808 ~ +9223372036854775807    (8 Bytes)
double         1.7 * 10^308        (8 Bytes)
```

```c++
// 预处理字符串： 
//  字符串转数字    -999,999,999 -->  -999999999
int int_to_string(string s)
{
    int front = 1 , i = 0;
    if(s[0] == '-') front = -1 , i++; //  负数处理
    
    int res = 0;
    while(i < s.size()){
        if(s[i] != ',') res = res * 10 + (s[i] - '0');
    	i++;
    }
    return res * front;
}
```

```c++
#include <iostream>
#include <sstream>   //  字符流
using namespace std;

int str2int(string s) {
    int a = 0, minus = 1, i = 0;
    if (s[0] == '-') {
        minus = -1;
        i = 1;
    }
    while (i < s.size()) {
        if (s[i] != ',') {
            a = a * 10 + (s[i] - '0');
        }
        i++;
    }
    return a * minus;
}

int main() {
    string str;
    while (getline(cin, str)) {
        stringstream ssin(str);  //  字符流加速
        
        string str1, str2;
        ssin >> str1 >> str2;

        cout << (str2int(str1) + str2int(str2)) << endl;
    }
    return 0;
}

```

#### 最长&最短文本

https://www.acwing.com/problem/content/description/3616/

```
map 的使用
```

```c++
#include <vector>
#include <iostream>
#include <map>
using namespace std;

map<int , vector<string>> mp;

int main()
{
    string str;
    while(cin >> str)
        mp[str.size()].emplace_back(str);
    
    
    for(auto i : mp.begin() -> second)
        cout << i << endl;
    
    auto it = mp.end();
    it--;
    for(auto i :  it -> second)
        cout << i << endl;
    
    
    return 0;
}

```



#### 数组推导

https://www.acwing.com/problem/content/4009/

$B_i = max \{ A_1 ,A2 , ... , A_i \}$

求  $MaxSum $ 时， 因为 $B_i$ 是前缀最大值。 要求预测的 $A_1 ... A_n$ 的最大值。

所以 $MaxSum$ 就是  $B_1 ... B_n $ 的和。

求 $MinSum$  时我们只需要求解拐点的和，其他的值全置为 $0$ 即可。

$b[i] > b[i-1]$ 时， $b[i]$  为拐点。

```c++
#include<iostream>
using namespace std;
const int N = 100010;
int n;
int b[N];
int main()
{
    cin >> n;
    for(int i = 0 ; i < n ; i++) cin >> b[i];
    
    int maxs = 0 ,mins = 0;
    for(int i = 0 ; i < n ; i++)
    {
        maxs += b[i];
        if(!i || b[i] > b[i-1])
            mins += b[i];
    }
    
    cout << maxs << endl << mins << endl;
    return 0;
}
```

#### 非零段划分

https://www.acwing.com/problem/content/4010/

![](image/pack_num.png)

```
从最高处向下取 p。
1：相邻山峰，对同一 P 下的山峰数无影响。所以先将整个数组去重。
2，3：延长左右山峰，山峰数不变
4：出现低谷，山峰数 – 1
5：出现山峰，山峰数 +1
```

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 500010 , M = 10010;

int n;
int a[N];
int cnt[N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
    
    n = unique(a + 1 , a + 1 + n) - (a + 1);
    a[0] = a[n + 1] = 0;
    
    for(int i = 1 ; i <= n ; i++)
    {
        int x = a[i - 1] , y = a[i] , z = a[i + 1];
        if(x < y && z < y) cnt[y]++;
        else if(x > y && z > y) cnt[y]--;
    }
    
    int res = 0 , sum = 0;
    for(int i = M - 1 ; i ; i--)
    {
        sum += cnt[i];
        res = max(res , sum);
    }
    printf("%d\n",res);
    return 0;
}
```

#### 1969：品种邻近 

https://www.acwing.com/problem/content/1971/

根据题意我们要找出在连续的输入数字中距离不超过 `k` 的两个相同数字来。可以用双指针或者滑动窗口来做。用滑动窗口的话。可以维护队列，队列元素始终为 `k` 个。

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int M = 1000010;
int cnt[M];
int n, k;

int main()
{
    scanf("%d%d", &n, &k);
    
    int res = -1;
    queue<int> q;
    for(int i = 0 ; i < n ; i++)
    {
        int id;
        scanf("%d", &id);
        
        // 当前滑动窗口中有这个数字。
        if(cnt[id] > 0) res = max(res , id); 
        cnt[id]++; 
        
        q.push(id); //  入队
        
        if(q.size() > k) // 超过滑动窗口的长度限制c
        {
            cnt[q.front()] --;
            q.pop();
        }
    }
    printf("%d\n",res);
    return 0;
}
```

#### 2058:笨拙的手指

https://www.acwing.com/problem/content/2060/

数据范围是 $[0,10^9]$ ，输入的数据是二进制和三进制，分别有一位错误。$10^9$ 的大概是 $2^{32}$ , 或者 $3^{20}$ 

因为只有一位不同，所以可以直接枚举。不同的位。 将他们转化为十进制的时间复杂度是 $o(logn)$ 

所以直接枚举就行。枚举的时候可将数据存储在哈希表中，方便在其中**快速查找**。`unordered_set`

位运算：因为使用 string 读入，所以是字符， ‘0’ 是 48 , ‘1’ 是49。 可直接使用异或运算。

相同为 $0$ ,相异为 $1$ 。即有： `0 ^ 1 = 1` , `1 ^ 1 = 0`

```c++
#include<bits/stdc++.h>
using namespace std;

int ToD(string a, int b)
{
    int num = 0;
    for(auto c : a)
    {
        num = num * b + c - '0';
    }
    return num;
}

int main()
{
    string a, b;
    cin >> a >> b;
    
    unordered_set<int> SA;
    
    for(auto& c :  a)  //  每次只改一位
    {
        c ^= 1;
        SA.insert(ToD(a , 2));
        c ^= 1;
    }
    
    for(auto& c :  b) // 使用引用才能在 增强 for 循环中改变 b, 不然只是拿出去遍历
    {
        char t = c;
        for(int i = 0 ; i < 3 ; i++)
            if(i + '0' != t) // 当前数字和不一样
            {
                c = i + '0'; // 就将其变成 该数字
                int x = ToD(b, 3);
                if(SA.count(x))
                {
                    cout << x << endl;
                    return 0;
                }
            }
        c = t;
    }
    
    
    return 0;
}
```

#### 2041：干草堆

https://www.acwing.com/problem/content/2043/

**基础算法：差分**

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1000010;
int n, k;
int a[N];

int main()
{
    scanf("%d%d", &n, &k);
    
    while(k--)
    {
        int l ,r;
        scanf("%d%d", &l, &r);
        a[l]++ , a[r + 1]--;
    }
    
    // 求差分数组的前缀和，也就是原数组。
    for(int i = 1 ; i <= n ; i++) a[i] += a[i - 1];

    // sort(a + 1 , a + 1 + n);
    
    // 直接使用库函数，其原理是 快排的变形。
    nth_element(a + 1, a + n / 2 + 1 , a + 1 + n);
    
    printf("%d\n" , a[n / 2 + 1]);

    return 0;
}
```

#### 2060：奶牛选美

https://www.acwing.com/problem/content/2062/

思路：先使用 Flood Fill 算法，求得连通块中点的坐标，然后去求两个连通块中任意两点的曼哈顿距离，取最小即可，注意曼哈顿距离 $- 1$ 。

```c++
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
const int N = 55;
typedef pair<int, int> PII; // 存坐标

int n, m;
char g[N][N];
vector<PII> points[2];

int dx[4] = {-1 , 0 , 1 , 0 } , dy[4] = {0 , 1 , 0 , -1};

// Flood Fill DFS
void dfs(int x ,int y ,vector<PII>& ps)
{
    g[x][y] = '.'; //  已经搜过 X , 就将其变成 '.'
    ps.emplace_back(x , y);
    
    for(int i = 0 ; i < 4 ; i++)
    {
        int a = x + dx[i] , b = y + dy[i];
        if (a < 0 || a >= n || b < 0 || b >= m || g[a][b] != 'X') continue;
        dfs(a, b, ps);
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    
    for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);
    for(int i = 0 , k = 0; i < n ; i++)
        for(int j = 0 ; j < m ; j++)
            if(g[i][j] == 'X')
                dfs(i, j , points[k++]);
                
    
    int res = 1e8;
    for(auto& a : points[0])
        for(auto& b : points[1])
            res = min(res , abs(a.x - b.x) + abs(a.y - b.y) - 1);
            
    printf("%d\n",res);
    
    return 0;
}
```



#### 2019：拖拉机

https://www.acwing.com/problem/content/2021/

![](image/acw_2019.png)

```c++
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 1010;
int n;
bool g[N][N];
int dist[N][N];
bool st[N][N];
int dx[4] = {-1 , 0 , 1 , 0} , dy[4] = {0 , 1,  0 , -1}; // 上右下左的顺序

int bfs(int sx, int sy)
{
    deque<PII> q;
    q.push_back({sx, sy});
    memset(dist , 0x3f , sizeof dist);
    dist[sx][sy] = 0;
    
    while(q.size())
    {
        auto t = q.front();
        q.pop_front();
        
        if(st[t.x][t.y]) continue;
        st[t.x][t.y] = 1;
        
        if(!t.x && !t.y) break; // 如果已经走到终点，直接退出就行
        
        for(int i = 0 ; i < 4 ; i++)
        {
            int x = t.x + dx[i] , y = t.y + dy[i];
            if(x >= 0 && x <= 1001 && y >= 0 && y <= 1001 )
            {
                int w = 0;
                if(g[x][y]) w = 1;
                if(dist[x][y] > dist[t.x][t.y] + w)
                {
                    dist[x][y] = dist[t.x][t.y] + w;
                    if(!w) q.push_front({x, y});
                    else q.push_back({x, y});
                }
            }
        }
        
    }
    return dist[0][0];
}

int main()
{
    int sx , sy;
    scanf("%d%d%d", &n , &sx , &sy);
    while(n--)
    {
        int x, y;
        scanf("%d%d", &x, &y);
        g[x][y] = 1;
    }
    
    printf("%d\n",bfs(sx, sy));
    
    return 0;
}
```

#### 2014：岛

https://www.acwing.com/problem/content/2016/

![](image/acw_2014.png)

岛的情况一共有上述五种情况，其中第 ① 种情况中，连续的相等的平面对于岛屿的数量是一样的，所以可以用离散化将重复的删掉即可。

```c++
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 100010;
int n;
int h[N];
PII q[N];

int main()
{
    scanf("%d", &n);
    for(int i = 1 ; i <= n ; i++) scanf("%d", &h[i]);
    
    n = unique(h + 1, h + 1 + n) - h - 1; // 判重
    // 后续代码可能会用到第n + 1个位置，需要把第n + 1个位置清空
    // 后续每次需要判断 三个位置的元素，所以需要这里需要清空
    h[n + 1] = 0;  
    
    for(int i = 1 ; i <= n ; i++) q[i] = {h[i] , i};
    
    sort(q + 1 , q + n + 1);
    
    int res = 1 , cnt = 1;
    for(int i = 1 ; i <= n ; i++)
    {
        int k = q[i].y;
        if(h[k - 1] < h[k] && h[k + 1] < h[k]) cnt--;
        else if(h[k-1] > h[k] && h[k + 1] > h[k]) cnt++;
        
        // 相同高度中，b最后一个高度被淹没才可去取。
        if(q[i].x != q[i + 1].x)
            res = max(res, cnt);
    }
    printf("%d\n",res);
    
    return 0;
}
```

#### 1952：金发姑娘和 N 头牛

https://www.acwing.com/problem/content/1954/

数据范围在 $-10^9$ ~ $10^9$ ,然后点数大概是 $20000 * 2$ ,所以要使用离散化。

![](image/CF.png)

每头奶牛对应一个区间，$n$ 个奶牛对应 $n$ 个区间 , 因为要计算是的所有奶牛的产量之和。

构造差分数组，然后在每个 区间输入 之后直接作用差分数组。

```
(-INF , L - 1]  ==>  b[-INF] += x ,  b[L + 1] -= x;
[L , R]         ==>  b[L] += y    ,  b[R + 1] -= y;
[R + 1, INF]    ==>  b[R + 1] += z , b[INF + 1] -= z;

综上：
        b[-INF] += x;
        b[l] += y - x;
        b[r + 1] += z - y;
        b[INF] -= z;
```

使用 `map` 的话，因为 `map`本身是平衡二叉树，然后会帮助我们自动离散化，但是对 `map`的操作是 $O(logn)$ 级别的。会增加时间复杂度。

```c++
#include<bits/stdc++.h>
using namespace std;
const int INF = 2e9;

int n, x, y, z;

int main()
{
    // 使用 map 做差分数组. 第一个 int 是对应每头牛的编号
    // 第二个 int 对应的是其产的牛奶
    map<int ,int> b; 
    
    scanf("%d%d%d%d", &n, &x, &y, &z);
    
    while(n--)
    {
        int l, r;
        scanf("%d%d", &l, &r);
        b[-INF] += x;
        b[l] += y - x;
        b[r + 1] += z - y;
        b[INF] -= z;
    }
    
    int res = 0 , sum = 0;
    for(auto& [k, v] : b) // 求差分数组的前缀和
    {
        sum += v;
        res = max(res , sum);
    }
    
    printf("%d\n", res);
    return 0;
}
```

手动实现离散化

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 20010 , INF = 2e9;

int n, x, y, z;
int l[N] , r[N] , b[N * 2];
vector<int> a;

int find(int x)
{
    int l = 0 , r = a.size() - 1;
    while(l < r)
    {
        int mid = l + r >> 1;
        if(a[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return l;
}

int main()
{
    
    scanf("%d%d%d%d", &n, &x, &y, &z);
    
    a.emplace_back(-INF);
    for(int i = 0 ; i < n ; i++)
    {
        scanf("%d%d", &l[i], &r[i]);
        a.emplace_back(l[i]);
        a.emplace_back(r[i] + 1);
    }
    
    sort(a.begin() , a.end());
    a.erase(unique(a.begin() , a.end()) , a.end());
    
    for(int i = 0 ; i < n ; i++)
    {
        int L = find(l[i]) , R = find(r[i] + 1);
        b[0] += x;
        b[L] += y - x;
        b[R] += z - y;
        b[a.size() - 1] -= z;
    }
    
    int res = 0 , sum = 0;
    for(int i = 0 ; i < a.size() - 1 ; i++)
    {
        sum += b[i];
        res = max(sum , res);
    }
    
    printf("%d\n", res);
    return 0;
}
```

#### 1945：奶牛棒球

https://www.acwing.com/problem/content/1947/

**使用双指针算法的前提： **  时间复杂度 $O(N)$

当且仅当两个指针都是单调的：其中一个指针向后移动时，另一个指针是否是 单调的移动（要么一直向前走，要么一直向后走）

![](image/acw_1945_1.jpg)

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int n;
int p[N];

int main()
{
    scanf("%d",&n);
    for(int i = 0 ; i < n ; i++) scanf("%d",&p[i]);

    sort(p , p + n);

    int res = 0;
    for(int i = 0 ; i < n + 2 ; i++)
        for(int j = i + 1 , l = j + 1, r = j + 1 ;j + 1 < n ; j++)
        {
            while(l < n && p[l] - p[j] < p[j] - p[i]) l++;
            while(r < n && p[r] - p[j] <= 2 * (p[j] - p[i])) r++;
            res += r - l;
        }
    printf("%d\n", res);

    return 0;
}

```

二分： $O(N^2logN)$

```c++
#include <bits/stdc++.h>
using namespace std;
int n, res= 0;
vector<int> a;
int main ()
{
    cin >> n;
    for (int & x : a) cin >> x;
    
    sort(a.begin(), a.end());
    
    for (int i = 0; i < n; i ++ )
        for (int j = i + 1; j < n; j ++ )
            res += upper_bound(a.begin(), a.end(), 3 * a[j] - 2 * a[i]) - lower_bound(a.begin(), a.end(), 2 * a[j] - a[i]);
    
    cout << res << endl;
    return 0;
}
```



























































































