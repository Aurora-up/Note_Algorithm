[TOC]



#### 单源最短路的综合应用



#### 1135：新年好 （DFS + 单源最短路）

https://www.acwing.com/problem/content/1137/

**关键语句：**拜访每个亲戚的顺序任意。要求时间最短。

**最短路分析：**

因为访问亲戚是**连续的**：从家出发之后，到达另一个亲戚家时，我们就又要考虑从该亲戚家到下一下亲戚的最短距离，所以需要我们求出  **以每个亲戚及自家为起点到其它点的最短距离**。（即：找到图中 6 个节点互相的最短路，然后就是 `tsp` 问题。一般用状压Dp解决，数据少，直接 DFS就好了）

**DFS分析：**

然后我们因为访问顺序任意，所以我们并不能确定 走完当前节点之后去哪个节点，我们只有一个原则：访问完所有时间最少。再看下数据，有 5 个节点，全排列枚举是 `5! = 120` 

$120 * 5*10^5 = 6 * 10^7$ 如果使用 spfa 的化，很可能被卡，所以可直接使用 堆优化Dijkstra 算法。

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
typedef pair<int, int> PII;
const int N = 50010 , M = 200010 , INF = 0x3f3f3f3f;

int n ,m;
int source[6];
int dist[6][N]; //  需要分别求从6 个起点开始的最短路。
bool st[N];
int h[N] , e[M] , ne[M] , w[M] ,idx;

void add(int a ,int  b ,int c)
{
    e[idx] = b , ne[idx] = h[a] , w[idx] = c , h[a] = idx++;
}

void dijkstra(int start , int dist[])
{
    memset(dist , 0x3f , N * 4);
    dist[start] = 0;
    memset(st , 0 , sizeof st);
    
    //  注意 dist 作为 第一关键字
    priority_queue< PII , vector<PII> , greater<PII>> heap;
    heap.push({0 , start});
    
    while(heap.size())
    {
        auto t = heap.top();
        heap.pop();
        
        int ver = t.second ;
        if(st[ver]) continue;
        st[ver] = 1;
        
        for(int i = h[ver] ; ~i ; i = ne[i])
        {
            int j = e[i];
            if(dist[j] > dist[ver] + w[i])
            {
                dist[j] = dist[ver] + w[i];
                heap.push({dist[j] , j});
            }
        }
    }
    
}

// u是拜访了到第几个亲戚 ， start 是从第几个开始拜， d 是当前距离
int dfs(int u, int start , int d)
{
    if(u > 5) return d;
    
    int res = INF;
    for(int i = 1 ; i <= 5 ; i++)
    {
        if(!st[i])
        {
            int next = source[i];
            
            st[i] = 1;
            res = min(res , dfs(u + 1 , i , d + dist[start][next]));
            st[i] = 0;
        }
    }
    return res;
}


int main()
{
    scanf("%d%d", &n, &m);
    source[0] = 1;
    for(int i = 1 ; i <= 5 ; i++) scanf("%d", &source[i]);
    memset(h, -1 ,sizeof h);
    while(m--)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b , &c);
        add(a, b, c) , add(b, a, c);
    }
    
    // 枚举 6 个点作为起点的 单源最短路。
    for(int i = 0 ; i < 6 ; i++) dijkstra(source[i] , dist[i]);
    
    memset(st, 0, sizeof st);
    printf("%d\n" , dfs(1 ,0 , 0));

    return 0;
}

```



#### 340：通信线路

https://www.acwing.com/problem/content/342/









#### 342：道路与航线

https://www.acwing.com/problem/content/344/











#### 341：最优贸易

https://www.acwing.com/problem/content/343/





































