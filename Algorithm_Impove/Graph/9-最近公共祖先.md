[TOC]

### **树的直径**

​		给定一棵树，树中每条边都有一个权值，树中两点之间的距离定义为连接两点路径上边权之和。树中最远的两个节点之间的距离被称为**树的直径**，连接这两点的路径被称为**树的最长链**。后者通常也可称为直径，即直径即是一个数值概念，也可以代指一条路径。

​		树的直径一般有两者求法，时间复杂度均是  $O(N)$ 。假设树以  $N$ 个点  $N-1$ 条边的无向图形式给出，并储存在邻接矩阵中。

#### **树形DP求解树的直径**

​		设 $1$ 号节点为根，$N$ 个点  $N-1$ 条边的无向图可以看作是 ”有根树“。

​		设 $D[x]$  表示从节点  $x$  出发走向以  $x$  为根的子树，能够到达的最远节点的距离。设  $x$  的子节点为   $y_1,y_2,...,y_t$ ，$edge(x, y)$ 表示边权，显然有：
$$
D[x]=max_{1≤i≤t}(D[y_i]+edge(x,y_i))
$$
​		考虑对每个节点  $x$  求出  ”经过节点  $x$  的最长链的长度 “   $F[x]$ ，那么整颗树的直径就是                $max_{1≤i≤n}(F[x])$ 。

​		如何求出 $F[x]$ ？对于  $x$  的任意两个节点   $y_i$ 和  $y_j$ ，” 经过节点  $x$  的最长链的长度  “ 可以通过四个部分构成：

1. 从  $y_i$  到  $y_i$  子树中的最短距离
2. 边  $(x , y_i)$
3. 边  $(x, y_j)$
4. 从  $y_j$   到  $y_j$ 子树中的最短距离 

设  $j<i$ ,因此有：
$$
F[x]=max_{1≤j≤i≤t}(D[y_i]+D[y_j]+edge(x,y_i)+edge(x,y_j))
$$
​		结合 $D[x]$ 的计算过程，在子节点的循环将要枚举到  $i$ 时， $D[x]$ 恰好保存了从节点  $x$  出发走向 ”以  $y_j(j<i)$  为根的子树，能够达到的最短节点的距离，这个距离是  $max_{1≤j<i}(D[y_j]+edge(x,y_j))$  ，所以我们先使用  $D[x]+D[y_i]+edge(x,y_i)$ 更新  $F[x]$ ，再用  $D[y_i] + edge(x,y_i)$ 更新 $D[x_i]$ 即可。

```c++
// v[N] 为标记数组 , h[N] ,e[N] ,ne[N] ,w[N] 均为模拟链表的数组
void dp(int x)
{
    v[x] = 1;
    for(int i = h[x] ; ~i ; i = ne[x])
    {
        int y = e[i];
        if(!v[y]){
            dp(y);
            ans = max(ans , d[x] + d[y] + w[i]);
            d[x] = max(d[x] , d[y] + w[i]);
        } 
    }
}
```

#### **两次 BFS 求解树的直径**

​		通过两次 BFS 或者两次  DFS 也能求出树的直径，并且容易计算出直径上的具体节点。做法包括两步。

1. 从任意一个节点出发，通过 BFS 或者 DFS 对树进行一次遍历，求出与出发点距离最远的节点，记为  $p$ 。
2. 从节点  $p$  出发，通过  BFS  或者  DFS  再进行一次遍历，求出与  $p$  距离最远的节点记为  $q$ 。

​		从  $p$  到  $q$  的路径就是树的一条直径，这是因为  $p$  一定是直径的一段，否则总能找到一个更长的链，与直径的定义矛盾。既然  $p$  是直径的一段，那么与  $p$  距离最远的  $q$  当然就是直径的另一端。

​		在第二步遍历过程中，可以记录下来每个点第一次被访问时的前驱节点，最后从  $q$  递归回到  $p$ ，即可得到直径的方案。

**注意**：

两次  BFS  求直径的方法 **只适用于边权均非负的情况** 。如果树上存在负权边，那么就不能成立。此时只能通过树形 DP 来求解。



### **最近公共祖先 (LCA)**

​		给定一棵有根树，若节点  $z$  既是节点  $x$  的祖先，也是节点   $y$   的祖先，则称  $z$  是  $x,y$
的公共祖先。在  $x,y$  的所有公共祖先中，**深度最大**的一个称为  $x,y$  的最近公共祖先，记为 $LCA(x,y)$。

![](image/LCA.png)



​		$LCA(x,y)$ 是 $x$ 到根的路径与 $y$ 到根的路径的交会点。它也是 **$x$ 与 $y$ 之间的路径上深度最小的节点**。求最近公共祖先的方法通常有三种：

#### **向上标记法**

​		从 $x$ 向上走到根节点，并标记所有经过的节点。
​		从 $y$ 向上走到根节点，当第一次遇到已标记的节点时，就找到了 $LCA(x,y)$。
​		对于每个询问，向上标记法的时间复杂度最坏为 $O(n)$。

#### **树上倍增法**

​		树上倍增法是一个很重要的算法。除了求 $LCA$ 之外，它在很多问题中都有广泛应用。设 $F[x,k]$  表示  $x$  的 $2^k$ 辈祖先 ，即从 $x$ 向根节点走 $2^k$  步到达的节点。特别地，若该节点不存在，则令 $F[x,k] = 0$。$F[x,0]$ 就是 $x$ 的父节点。除此之外，

​						任意的 $k∈[1, logn], F[x,k] = F[F[x,k - 1],k - 1]$ 。

​		这类似于一个动态规划的过程，“阶段” 就是节点的**深度**。因此，我们可以对树进行广度优先遍历，按照层次顺序，在节点入队之前，计算它在 $F$ 数组中相应的值。以上部分是预处理，时间复杂度为 $O(n logn)$，之后可以多次对不同的 $x,y$  计算 $LCA$，每次询问的时间复杂度为 $O(logn)$。
基于 $F$ 数组计算 $LCA(x,y)$ 分为以下几步：

1. 设 $d[x]$ 表示 $x$ 的深度。不妨设 $d[x]≥ d[y]$（否则可交换  $x,y$ )。
2. 用二进制拆分思想，把 $x$ 向上调整到与 $y$ 同一深度。具体来说，就是依次尝试从 $x$ 向上走 $k = 2^{logn} , … , 2^1 , 2^0$ 步，检查到达的节点是否比 $y$ 深。在每次检查中，若是，则令 $x = F[x,k]$。
3. 若此时 $x = y$，说明已经找到了 $LCA$，$LCA$ 就等于  $y$。

这就是上面的图中的第三种情况。

  4：用二进制拆分思想，把 $x,y$ 同时向上调整，并保持深度一致且二者不相会。具体来说，就是依次尝试把 $x,y$ 同时向上走  $k = 2^{logn} , … , 2^1 , 2^0$  步，在每次尝试中，若 $F[x,k]≠F[y,k]$（即仍未相会），则令 $x = F[x,k],y = F[y,k]$。
  5：此时 $x,y$ 必定只差一步就相会了，它们的父节点  $F[x,0]$  就是 $LCA$。

多次查询树上两点之间的距离，时间复杂度为 $O((n + m)logn)$。





#### 1172：祖孙询问

https://www.acwing.com/problem/content/1174/







#### 1171：距离

https://www.acwing.com/problem/content/1173/







#### 356：次小生成树

https://www.acwing.com/problem/content/description/358/





#### 352：闇の連鎖

https://www.acwing.com/problem/content/description/354/









#### 练习：

##### 350：巡逻

https://www.acwing.com/problem/content/352/





##### 351：树网的核

https://www.acwing.com/problem/content/353/





##### 353：雨天的尾巴

https://www.acwing.com/problem/content/355/







##### 354：天天爱跑步

https://www.acwing.com/problem/content/356/





##### 355：异像石

https://www.acwing.com/problem/content/357/







##### 357：疫情控制

https://www.acwing.com/problem/content/359/















